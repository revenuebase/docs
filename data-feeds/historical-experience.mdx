---
title: "Historical Experience"
sidebarTitle: "Historical Experience"
description: "Career history and job change data â€” past roles, tenure, and professional trajectory."
---

The `historical_experience` table tracks career history for contacts in the RevenueBase database. Each row represents one LinkedIn profile with an array of job positions. Use it to understand career trajectories, identify recent job changers, find alumni of specific companies, and build more personalized outreach.

## Where the data comes from

Historical experience is derived from professional profiles and public career history. Positions are normalized to titles, seniority, and department where possible. Start and end dates are captured with the precision available from the source (sometimes year-only for older roles). Tenure is calculated from those dates.

## Counts and coverage

Each row represents one LinkedIn profile with an array of job positions. Not every contact has historical experience; fill rates are higher for recent roles and for people with detailed public profiles. Use the fill-rate query below to see coverage and average positions per profile.

## Table stats

| Metric | Value |
|--------|-------|
| **Total records** | One row per LinkedIn profile (with array of jobs) |
| **Update frequency** | Monthly (aligned with contacts release) |
| **Primary key** | `linkedin_url` |
| **Main foreign keys** | Join to `person` table on `linkedin_url`, join to `organisation` table via `rbid_org` |

## Data dictionary & fill rates

Fill rates for historical data are typically lower than for current-position data. Older positions, smaller companies, and non-US contacts tend to have less complete records. The table structure uses one row per LinkedIn profile with an array of job positions.

### Top-level fields

| Field | Type | Description |
|-------|------|-------------|
| `unique_id` | VARCHAR | Unique identifier for this record |
| `linkedin_url` | VARCHAR | LinkedIn profile URL (primary key) |
| `job_count` | INTEGER | Maximum number of jobs for this profile |
| `jobs` | ARRAY | Array of job objects containing experience data |

### Jobs array structure

Each element in the `jobs` array is an object containing:

| Field | Type | Description |
|-------|------|-------------|
| `rbid` | VARCHAR | RevenueBase person identifier (from person table) |
| `rbid_pao` | VARCHAR | RevenueBase person-at-organization identifier |
| `rbid_org` | VARCHAR | RevenueBase organization identifier |
| `linkedin_id` | VARCHAR | LinkedIn company page ID (from organisation table) |
| `email_address` | VARCHAR | Email address (from person table) |
| `experience` | OBJECT | Experience details (title, company, dates, etc.) |

<Info>**One row per LinkedIn profile with array of jobs.** Each row contains a `jobs` array with all positions for that profile. The `experience` object within each job contains the position details (title, company, start_date, end_date, etc.). Use array functions to query and filter individual positions.</Info>

<Note>The `experience` object structure may vary, but typically includes fields like `title`, `company_name`, `start_date`, `end_date`, `is_current`, and other position-related attributes. Query the array to access individual job positions.</Note>

### Joining to other tables

The `jobs` array contains `rbid`, `rbid_org`, and `email_address` that you can use to join to other tables:

| Approach | When to use |
|----------|-------------|
| **Join to person table** | Use `jobs[].rbid` or join on `linkedin_url` to get current contact information |
| **Join to organisation table** | Use `jobs[].rbid_org` to get company firmographics and HQ address for that employer |
| **Contact's current location** | For "where does this person live now," use **contacts** (`CITY`, `STATE_NAME`, `COUNTRY_NAME`), not historical experience |

<Tip>To analyze "contacts who worked in California" or "alumni of companies in EMEA," flatten the `jobs` array, join to `organisation` on `rbid_org`, and filter on company location fields.</Tip>

<Warning>**Fill rates for historical data are inherently lower** than for current-position data. Older positions, smaller companies, and non-US contacts tend to have less complete records. The `experience` object may not contain all fields for every position, and `rbid_org` may be null when the employer is not in the RevenueBase companies table.</Warning>

## Common use cases

<AccordionGroup>
  <Accordion title="Find recent job changers">
    People who just started a new role are often more receptive to new tools. Flatten the `jobs` array and filter for positions where `experience.is_current = TRUE` and `experience.start_date` is within the last 90 days.
  </Accordion>
  <Accordion title="Company alumni targeting">
    Find everyone who used to work at a specific company by flattening the `jobs` array and filtering for `experience.company_domain` or using `rbid_org` to join to the organisation table. Filter for `experience.is_current = FALSE`. Useful for selling to former champions who already know your space.
  </Accordion>
  <Accordion title="Career trajectory analysis">
    Flatten the `jobs` array and compare titles and seniority across positions for a profile. Use `job_count` to identify profiles with multiple positions, then analyze the progression in the `jobs` array.
  </Accordion>
  <Accordion title="Tenure-based signals">
    Calculate tenure from `experience.start_date` and `experience.end_date` in the flattened jobs array. Short average tenure can indicate high turnover; long tenure at current role can indicate stability and buying authority.
  </Accordion>
</AccordionGroup>

## Joining this table

Join **historical_experience** to **person** table on `linkedin_url` to get current contact info. Use the `jobs` array to access individual positions. Join to **organisation** table using `jobs[].rbid_org` when you need firmographics or HQ address for a specific role.

### Flattening the jobs array

To work with individual positions, you need to flatten the `jobs` array. Here's a pattern for Snowflake:

```sql
SELECT
    he.linkedin_url,
    he.unique_id,
    job.value:rbid AS rbid,
    job.value:rbid_org AS rbid_org,
    job.value:email_address AS email_address,
    job.value:experience AS experience
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he,
LATERAL FLATTEN(input => he.jobs) job
WHERE job.value:experience IS NOT NULL;
```

### Historical experience + contacts (recent job changers with contact info)

```sql
SELECT
    per.FIRST_NAME,
    per.LAST_NAME,
    per.EMAIL_ADDRESS,
    job.value:experience:title AS new_title,
    job.value:experience:company_name AS new_company,
    job.value:experience:start_date AS start_date,
    per.JOB_TITLE AS current_title_in_feed
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he
JOIN RELEASES.RELEASE.PER_LATEST per ON he.linkedin_url = per.LINKEDIN_URL
, LATERAL FLATTEN(input => he.jobs) job
WHERE job.value:experience:is_current = TRUE
  AND job.value:experience:start_date >= DATEADD(day, -90, CURRENT_DATE())
  AND per.EMAIL_ADDRESS IS NOT NULL
ORDER BY job.value:experience:start_date DESC;
```

### Historical experience + contacts + companies (alumni with HQ location)

```sql
SELECT
    per.FIRST_NAME,
    per.LAST_NAME,
    per.EMAIL_ADDRESS,
    job.value:experience:company_name AS former_employer,
    job.value:experience:title AS former_title,
    job.value:experience:start_date AS start_date,
    job.value:experience:end_date AS end_date,
    org.HEADQUARTERS_COUNTRY_NAME,
    org.HEADQUARTERS_CITY
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he
JOIN RELEASES.RELEASE.PER_LATEST per ON he.linkedin_url = per.LINKEDIN_URL
, LATERAL FLATTEN(input => he.jobs) job
LEFT JOIN RELEASES.RELEASE.ORG_LATEST org ON job.value:rbid_org = org.RBID
WHERE job.value:experience:company_domain = 'salesforce.com'
  AND job.value:experience:is_current = FALSE
  AND per.EMAIL_ADDRESS IS NOT NULL
ORDER BY job.value:experience:end_date DESC;
```

## How to calculate fill rates

Use this to see how many profiles you have, how many positions total, and how complete key fields are.

```sql
SELECT
    COUNT(*) AS total_profiles,
    SUM(job_count) AS total_positions,
    ROUND(AVG(job_count), 1) AS avg_positions_per_profile,
    COUNT(DISTINCT linkedin_url) AS unique_profiles
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST;

-- To analyze individual positions, flatten the array first:
SELECT
    COUNT(*) AS total_positions,
    ROUND(COUNT(job.value:rbid_org) * 100.0 / COUNT(*), 1) AS rbid_org_fill_pct,
    ROUND(COUNT(job.value:experience:title) * 100.0 / COUNT(*), 1) AS title_fill_pct,
    ROUND(COUNT(job.value:experience:start_date) * 100.0 / COUNT(*), 1) AS start_date_fill_pct
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he,
LATERAL FLATTEN(input => he.jobs) job
WHERE job.value:experience IS NOT NULL;
```

## Sample queries

### Recent job changers (last 90 days)

**What you're finding:** People who started a new job in the last 90 days, for outreach or lead scoring.

**Why these fields:** We need current contact info from the person table and the new role from the flattened jobs array. Filter for current positions with recent start dates.

**Logic:** Flatten the jobs array, filter to current positions (`is_current = TRUE`) with `start_date` in the last 90 days. Join to person table for contact info.

```sql
SELECT
    per.FIRST_NAME,
    per.LAST_NAME,
    per.EMAIL_ADDRESS,
    job.value:experience:title AS new_title,
    job.value:experience:company_name AS new_company,
    job.value:experience:start_date AS start_date
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he
JOIN RELEASES.RELEASE.PER_LATEST per ON he.linkedin_url = per.LINKEDIN_URL
, LATERAL FLATTEN(input => he.jobs) job
WHERE job.value:experience:is_current = TRUE
  AND job.value:experience:start_date >= DATEADD(day, -90, CURRENT_DATE())
  AND per.EMAIL_ADDRESS IS NOT NULL
ORDER BY job.value:experience:start_date DESC;
```

### Alumni of a specific company

**What you're finding:** People who used to work at a given company (e.g. Salesforce), with current contact info, for alumni campaigns or competitive targeting.

**Why these fields:** Filter the jobs array for the target company domain and non-current positions. Join to person table for current contact info.

**Logic:** Flatten the jobs array, filter by target company domain and non-current positions. Join to person table for email and current context. Order by `end_date` descending so the most recent leavers appear first.

```sql
SELECT
    per.FIRST_NAME,
    per.LAST_NAME,
    per.EMAIL_ADDRESS,
    per.JOB_TITLE AS current_title,
    per.COMPANY_NAME AS current_company,
    job.value:experience:title AS former_title,
    job.value:experience:start_date AS start_date,
    job.value:experience:end_date AS end_date
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he
JOIN RELEASES.RELEASE.PER_LATEST per ON he.linkedin_url = per.LINKEDIN_URL
, LATERAL FLATTEN(input => he.jobs) job
WHERE job.value:experience:company_domain = 'salesforce.com'
  AND job.value:experience:is_current = FALSE
  AND per.EMAIL_ADDRESS IS NOT NULL
ORDER BY job.value:experience:end_date DESC;
```

### Profiles with multiple positions

**What you're finding:** Profiles that have held multiple positions, useful for career trajectory analysis.

**Why these fields:** Use `job_count` to identify profiles with multiple positions, then flatten to see all positions.

**Logic:** Filter for profiles with `job_count > 1`, then flatten the jobs array to see all positions.

```sql
SELECT
    he.linkedin_url,
    he.job_count,
    per.FIRST_NAME,
    per.LAST_NAME,
    job.value:experience:title AS job_title,
    job.value:experience:company_name AS company_name,
    job.value:experience:start_date AS start_date,
    job.value:experience:end_date AS end_date,
    job.value:experience:is_current AS is_current
FROM RELEASES.RELEASE.HISTORICAL_EXPERIENCE_LATEST he
JOIN RELEASES.RELEASE.PER_LATEST per ON he.linkedin_url = per.LINKEDIN_URL
, LATERAL FLATTEN(input => he.jobs) job
WHERE he.job_count > 1
  AND job.value:experience IS NOT NULL
ORDER BY he.linkedin_url, job.value:experience:start_date DESC;
```
